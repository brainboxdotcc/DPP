<?php
exec("cat src/dpp/cluster/*.cpp", $clustercpp);
$blacklist = [
	'channel_edit_permissions',
	'message_add_reaction',
	'message_delete_reaction',
	'message_delete_reaction_emoji',
	'message_delete_all_reactions',
	'message_delete_own_reaction',
	'message_get_reactions',
	'channel_typing',
];
$forcedReturn = [
	'direct_message_create' => 'message',
	'guild_get_members' => 'guild_member_map',
	'guild_search_members' => 'guild_member_map',
	'message_create' => 'message',
	'message_edit' => 'message',
];
$header = explode("\n", file_get_contents('include/dpp/cluster.h'));
$state = 0;
$currentFunction = $parameters = $returnType = '';
$content = '';
$content = <<<EOT
/************************************************************************************
 *
 * D++, A Lightweight C++ library for Discord
 *
 * Copyright 2022 Craig Edwards and D++ contributors
 * (https://github.com/brainboxdotcc/DPP/graphs/contributors)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ************************************************************************************/


/* Auto-generated by buildtools/make_sync_struct.php.
 *
 * DO NOT EDIT BY HAND!
 *
 * To re-generate this header file re-run the script!
 */ 


EOT;

$us = file_exists('include/dpp/cluster_sync_calls.h') ? filemtime('include/dpp/cluster_sync_calls.h') : 0;
$them = filemtime('include/dpp/cluster.h');
if ($them <= $us) {
	echo "-- No change required.\n";
	exit(0);
}

echo "-- Autogenerating include/dpp/cluster_sync_calls.h\n";

foreach ($clustercpp as $cpp) {
	if ($state == 0 && preg_match('/^\s*void\s+cluster::([^(]+)\s*\((.*)command_completion_event_t\s*callback\s*\)/', $cpp, $matches)) {
		$currentFunction = $matches[1];
		$parameters = preg_replace('/,\s*$/', '', $matches[2]);
		if (!in_array($currentFunction, $blacklist)) {
			$state = 1;
		}
	} elseif ($state == 1) {
		if (preg_match('/^\}\s*$/', $cpp)) {
			$state = 2;
		} elseif (preg_match('/rest_request<([^>]+)>/', $cpp, $matches)) {
			$returnType = $matches[1];
		} elseif (preg_match('/rest_request_list<([^>]+)>/', $cpp, $matches)) {
			$returnType = $matches[1] . '_map';
		} elseif (preg_match('/callback\(confirmation_callback_t\(\w+, ([^(]+)\(\).*, \w+\)\)/', $cpp, $matches)) {
			$returnType = $matches[1];
		} elseif (!empty($forcedReturn[$currentFunction])) {
			$returnType = $forcedReturn[$currentFunction];
		}
	}
	if ($state == 2 && !empty($currentFunction) && !empty($returnType)) {
		if (!in_array($currentFunction, $blacklist)) {
			$parameterList = explode(',', $parameters);
			$parameterNames = [];
			foreach ($parameterList as $parameter) {
				$parts = explode(' ', trim($parameter));
				$parameterNames[] = trim(preg_replace('/[\s\*\&]+/', '', $parts[count($parts) - 1]));
			}
			$content .= getComments($currentFunction, $returnType, $parameterNames) . "\n";
			$fullParameters = getFullParameters($currentFunction, $parameterNames);
			$parameterNames = trim(join(', ', $parameterNames));
			if (!empty($parameterNames)) {
				$parameterNames = ', ' . $parameterNames;
			}
			$parameters = !empty($fullParameters) ? $fullParameters : $parameters;
			$content .= "inline $returnType {$currentFunction}_sync($parameters) {\n\treturn dpp::sync<$returnType>(this, &cluster::$currentFunction$parameterNames);\n}\n\n";
		}
		$currentFunction = $parameters = $returnType = '';
		$state = 0;
	}
}
$content .= <<<EOT

/* End of auto-generated definitions */

EOT;

function getFullParameters(string $currentFunction, array $parameters): string {
	global $header;
	$arr = [];
	foreach ($header as $line) {
		if (preg_match('/^\s*void\s+' . $currentFunction . '\s*\((.*' . join('.*', $parameters) . '.*)command_completion_event_t\s*callback\s*/', $line, $matches)) {
			return preg_replace('/,\s*$/', '', $matches[1]);
		}
	}
	return '';
}


function getComments(string $currentFunction, string $returnType, array $parameters): string {
	global $header;
	/* First find the function */
	foreach ($header as $i => $line) {
		if (preg_match('/^\s*void\s+' . $currentFunction . '\s*\(.*' . join('.*', $parameters) . '.*command_completion_event_t\s*callback\s*/', $line)) {
			/* Backpeddle */
			$x = 1;
			$messageToRemove = -1;
			for ($n = $i; $n != 0; --$n, $x++) {
				$header[$n] = preg_replace('/^\t+/', '', $header[$n]);
				$header[$n] = preg_replace('/@param callback .*$/', '@return ' . $returnType . ' returned object on completion', $header[$n]);
				if (preg_match('/\s*\* On success /i', $header[$n])) {
					$header[$n] = "";
				}
				if (preg_match('/\s*\/\*\*\s*$/', $header[$n])) {
					$part = array_slice($header, $n, $x - 1);
					array_splice($part, count($part) - 1, 0,
						[
							" * \memberof dpp::cluster",
							" * @see dpp::cluster::" . $currentFunction,
							" * @throw dpp::rest_exception upon failure to execute REST function",
							" * @warning This function is a blocking (synchronous) call and should only be used from within a separate thread.",
							" * Avoid direct use of this function inside an event handler.",
						]
					);
					return str_replace("\n\n", "\n", join("\n", $part));
				}
			}
			return '';
		}
	}
	return '';
}

file_put_contents('include/dpp/cluster_sync_calls.h', $content);
